import { TYPES } from '../constants';
import { IColumn } from '../interfaces';

export const validateColumns = (columns: IColumn[]) => {
  const columnErrors = columns.map((item) => {
    const errors: string[] = [];

    if (typeof item.name !== 'string') {
      errors.push(`Invalid type for name: ${item.name}`);
    }

    if (!TYPES.includes(item.type)) {
      errors.push(`Invalid type: ${item.type}`);
    }

    if (typeof item.required !== 'boolean') {
      errors.push(`Invalid type for required: ${item.required}`);
    }

    if (item.autoGenerated !== undefined && typeof item.autoGenerated !== 'boolean') {
      errors.push(`Invalid type for autoGenerated: ${item.autoGenerated}`);
    }

    if (item.min !== undefined && typeof item.min !== 'number') {
      errors.push(`Invalid type for min: ${item.min}`);
    }

    if (item.max !== undefined && typeof item.max !== 'number') {
      errors.push(`Invalid type for max: ${item.max}`);
    }

    if (item.min !== undefined && item.max !== undefined && item.min >= item.max) {
      errors.push(`min should be less than max: min=${item.min}, max=${item.max}`);
    }

    if (
      item.defaultValue !== undefined &&
      item.defaultValue !== null &&
      !['string', 'number', 'boolean'].some(type => typeof item.defaultValue === type)
    ) {
      errors.push(`Invalid type for defaultValue: ${item.defaultValue}`);
    }

    return errors.length > 0 ? { name: `${item.name}`, errors } : null;
  }).filter(Boolean);

  return columnErrors;
};
